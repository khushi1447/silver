// Prisma schema for Jewelry E-commerce
// Run: npx prisma generate && npx prisma migrate dev

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql" // Change to your DB (postgresql, mysql, sqlite, etc.)
  url      = env("DATABASE_URL")
}

model User {
  id          Int       @id @default(autoincrement())
  firstName   String
  lastName    String
  email       String    @unique
  password    String
  phone       String?
  isAdmin     Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  orders    Order[]
  reviews   Review[]
  wishlist  WishlistItem[]
  addresses Address[]
  cart      CartItem[]
  returnRequests ReturnRequest[]
}

model Category {
  id          Int       @id @default(autoincrement())
  name        String    @unique
  description String?
  imageUrl    String?
  products    Product[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model Product {
  id                Int      @id @default(autoincrement())
  name              String
  description       String?
  shortDescription  String?
  price             Decimal  @db.Decimal(10, 2) 
  stock             Int      @default(0)
  lowStockThreshold Int      @default(5)

  category   Category @relation(fields: [categoryId], references: [id])
  categoryId Int

  weight        Decimal? @db.Decimal(8, 3)
  size          String? // ring size, chain length, etc.

  // Relations
  images        ProductImage[]
  orderItems    OrderItem[]
  reviews       Review[]
  wishlistItems WishlistItem[]
  cartItems     CartItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}


model Order {
  id          Int    @id @default(autoincrement())
  orderNumber String @unique // human-readable order number
  user        User   @relation(fields: [userId], references: [id])
  userId      Int

  // Order status enum values: pending, confirmed, processing, shipped, delivered, cancelled, refunded
  status OrderStatus @default(PENDING)

  // Pricing
  subtotal       Decimal @db.Decimal(10, 2)
  taxAmount      Decimal @default(0) @db.Decimal(10, 2)
  shippingCost   Decimal @default(0) @db.Decimal(10, 2)
  discountAmount Decimal @default(0) @db.Decimal(10, 2)
  totalAmount    Decimal @db.Decimal(10, 2)

  // Applied coupon
  coupon     Coupon? @relation(fields: [couponId], references: [id])
  couponId   Int?
  couponCode String? // store the code used

  // Addresses
  billingAddress  Json
  shippingAddress Json

  // Order notes
  customerNotes String?

  // Relations
  orderItems OrderItem[]
  payments   Payment[]
  shipping   Shipping?
  returnRequests ReturnRequest[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

model OrderItem {
  id         Int     @id @default(autoincrement())
  order      Order   @relation(fields: [orderId], references: [id])
  orderId    Int
  product    Product @relation(fields: [productId], references: [id])
  productId  Int
  quantity   Int
  price      Decimal @db.Decimal(10, 2) // price at order time
  totalPrice Decimal @db.Decimal(10, 2) // price * quantity

  // Store product details at time of order
  productName  String
  productSku   String
  productImage String?
}

model Setting {
  id          Int      @id @default(autoincrement())
  category    String // general, payment, shipping, email, etc.
  key         String   @unique
  value       String
  description String?
  dataType    String   @default("string") // string, number, boolean, json
  isPublic    Boolean  @default(false) // can be accessed by frontend
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Admin and audit models
model AdminLog {
  id         Int      @id @default(autoincrement())
  adminId    Int
  action     String // create, update, delete, etc.
  resource   String // product, order, user, etc.
  resourceId Int?
  oldValues  Json?
  newValues  Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())
}

model Payment {
  id              Int           @id @default(autoincrement())
  order           Order         @relation(fields: [orderId], references: [id])
  orderId         Int
  paymentMethod   PaymentMethod
  gateway         String? // stripe, razorpay, paypal, etc.
  amount          Decimal       @db.Decimal(10, 2)
  currency        String        @default("INR")
  status          PaymentStatus
  transactionId   String?
  gatewayResponse Json?
  failureReason   String?
  paidAt          DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

enum PaymentMethod {
  CREDIT_CARD
  DEBIT_CARD
  UPI
  NET_BANKING
  WALLET
  COD
  BANK_TRANSFER
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

model Coupon {
  id            Int          @id @default(autoincrement())
  code          String       @unique
  name          String // internal name
  description   String?
  discountType  DiscountType
  discountValue Decimal      @db.Decimal(10, 2)
  minOrderValue Decimal      @default(0) @db.Decimal(10, 2)
  maxDiscount   Decimal?     @db.Decimal(10, 2) // max discount for percentage coupons

  // Usage limits
  usageLimit   Int? // total usage limit
  usageCount   Int  @default(0)
  perUserLimit Int? // per user usage limit

  // Validity
  startsAt  DateTime?
  expiresAt DateTime?
  isActive  Boolean   @default(true)

  // Applicable products/categories
  applicableProducts   String? // comma-separated product IDs
  applicableCategories String? // comma-separated category IDs

  orders    Order[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
  FREE_SHIPPING
}

// Additional models for comprehensive jewelry e-commerce

model ProductImage {
  id        Int      @id @default(autoincrement())
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId Int
  url       String
  altText   String?
  sortOrder Int      @default(0)
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
}

model CartItem {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId Int
  quantity  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, productId])
}

model Review {
  id           Int      @id @default(autoincrement())
  user         User     @relation(fields: [userId], references: [id])
  userId       Int
  product      Product  @relation(fields: [productId], references: [id])
  productId    Int
  rating       Int // 1-5 stars
  title        String?
  comment      String?
  isVerified   Boolean  @default(false) // verified purchase
  isApproved   Boolean  @default(false) // admin approval
  adminReply   String?
  helpfulCount Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([userId, productId]) // one review per user per product
}

model WishlistItem {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  product   Product  @relation(fields: [productId], references: [id])
  productId Int
  createdAt DateTime @default(now())

  @@unique([userId, productId])
}

model Address {
  id         Int         @id @default(autoincrement())
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     Int
  type       AddressType
  firstName  String
  lastName   String
  company    String?
  address1   String
  address2   String?
  city       String
  state      String
  postalCode String
  country    String      @default("US")
  phone      String?
  isDefault  Boolean     @default(false)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
}

enum AddressType {
  BILLING
  SHIPPING
  BOTH
}

model Shipping {
  id                Int            @id @default(autoincrement())
  order             Order          @relation(fields: [orderId], references: [id])
  orderId           Int            @unique
  method            ShippingMethod
  cost              Decimal        @db.Decimal(10, 2)
  trackingNumber    String?
  carrier           String? // FedEx, UPS, DHL, etc.
  status            ShippingStatus @default(PENDING)
  estimatedDelivery DateTime?
  shippedAt         DateTime?
  deliveredAt       DateTime?
  notes             String?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
}

enum ShippingMethod {
  STANDARD
  EXPRESS
  OVERNIGHT
  FREE
  LOCAL_DELIVERY
}

enum ShippingStatus {
  PENDING
  PROCESSING
  SHIPPED
  IN_TRANSIT
  OUT_FOR_DELIVERY
  DELIVERED
  FAILED
  RETURNED
}

// -----------------------------
// Returns & Refunds Management
// -----------------------------

enum ReturnStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

enum ReturnResolutionType {
  REFUND
  EXCHANGE
  STORE_CREDIT
}

// You may also store a free-text reason (e.g., "Damaged", "Wrong product")
model ReturnRequest {
  id              Int                    @id @default(autoincrement())

  // Relations
  order           Order                  @relation(fields: [orderId], references: [id])
  orderId         Int
  user            User?                  @relation(fields: [userId], references: [id])
  userId          Int?

  // Details
  reason          String
  photos          String[]               // Postgres text[] to store image URLs
  resolutionType  ReturnResolutionType
  status          ReturnStatus           @default(PENDING)
  rejectionReason String?

  // Optional operational fields
  pickupWaybill   String?                // Delhivery waybill for pickup (if any)
  refundId        String?                // Razorpay refund id (if processed)

  // Logs
  logs            ReturnLog[]

  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
}

model ReturnLog {
  id               Int           @id @default(autoincrement())
  returnRequest    ReturnRequest @relation(fields: [returnRequestId], references: [id], onDelete: Cascade)
  returnRequestId  Int

  status           ReturnStatus
  note             String?
  adminId          Int?          // optional admin who performed the action

  createdAt        DateTime      @default(now())
}
